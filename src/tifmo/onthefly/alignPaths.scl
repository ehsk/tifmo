package tifmo

import dcstree.DCSTreeNode
import dcstree.DCSTreeEdgeNormal
import dcstree.DCSTreeEdgeQuantifier
import dcstree.Ref
import dcstree.Denotation
import dcstree.DenotationWordSign
import dcstree.DenotationPI
import dcstree.Declarative
import dcstree.DeclarativeSubRef
import inference.IEngine
import inference.Term

import scala.collection.mutable

package onthefly {
	/**
	 * Function object `alignPaths` takes assumptions 
	 * generated by an [[tifmo.onthefly.AEngine]] and produces path alignments. 
	 * 
	 * These path alignments are intuitive tree transformations motivated by the assumptions, 
	 * but may or may not generate the knowledge that implies the assumptions. 
	 * 
	 * We use several logical constraints to filter out meaningless path alignments. 
	 * Check the `if` conditions in source code for details. 
	 */
	object alignPaths extends ((Set[Declarative], IEngine) => Set[PathAlignment]) {
		/**
		 * Inference engine terms necessary for the later aligning and filtering process should be 
		 * constructed beforehand, otherwise these terms may be lost due to merge by inference engine.
		 */
		def init(assumption: Set[Declarative], ie: IEngine) {
			val nodespool = mutable.Set.empty[DCSTreeNode]
			for (DeclarativeSubRef(sub, sup) <- assumption) {
				nodespool += sub.node
				nodespool ++= sub.subOrdinate.map(_._3.node)
				nodespool += sup.node
				nodespool ++= sup.subOrdinate.map(_._3.node)
			}
			for (n <- nodespool) {
				ie.getTerm(n.output)
				n.rseq.foreach(r => ie.getTerm(n.germ(r)))
				val qtrs = if (n.positiveTree) n.rseq.toSet else n.rseq.takeWhile(_ != n.outRole).toSet
				for ((e:DCSTreeEdgeQuantifier, nn) <- n.children; if qtrs.contains(e.inRole)) {
					ie.getTerm(nn.output)
				}
			}
		}
		
		private[this] def wordPIs(den: Denotation) = {
			if (den.roles.size == 1) Set(den) else den.roles.map(r => DenotationPI(den, Set(r)))
		}
		
		def apply(assumption: Set[Declarative], ie: IEngine) = {
			
			val clueTerms = ie.allDenotationWordSign.flatMap(x => wordPIs(x).map(ie.getTerm(_)))
			
			for {
				DeclarativeSubRef(sub, sup) <- assumption
				supempty = ie.getTerm(sup.getDenotation).selfDisjoint
				if supempty || logicallyRelated(ie, clueTerms, sub, sup)
				subPaths = generatePaths(sub)
				supPaths = generatePaths(sup)
				subPath <- subPaths
				supPath <- supPaths
				if subPath.rnrs.length <= 5
				if supPath.rnrs.length <= 5
				if supempty || logicallyAlignedUp(ie, clueTerms, subPath, supPath)
				if logicallyAlignedDown(ie, clueTerms, subPath, supPath)
				if signMatch(subPath, supPath)
				if !headStopWord(subPath)
				if !headNamedEntity(supPath)
			} yield {
				PathAlignment(subPath, supPath)
			}
		}
		
		private[this] def clue(ie: IEngine, clueTerms: Set[Term], den: Denotation) = {
			assert(den.roles.size == 1)
			val tm = ie.getTerm(den)
			val ret1 = tm.superSets.filter(!_.isW) intersect clueTerms
			val ret2 = if (tm.selfDisjoint) Set.empty[Term] else tm.disjointSets.filter(!_.selfDisjoint)
			(ret1, ret2)
		}
		
		private[this] def logicallyRelated(ie: IEngine, clueTerms: Set[Term], a: Ref, b: Ref) = {
			val (aClue1, aClue2) = clue(ie, clueTerms, a.node.germ(a.role))
			val (bClue1, bClue2) = clue(ie, clueTerms, b.node.germ(b.role))
			!(aClue1 intersect bClue1).isEmpty || !(aClue2 intersect bClue2).isEmpty
		}
		
		private[this] def generatePaths(ref: Ref) = {
			val tmp = ref.subOrdinate + ((Seq.empty[(DCSTreeNode, DCSTreeEdgeNormal)], Seq.empty[(DCSTreeEdgeNormal, DCSTreeNode)], ref))
			for {
				(asc, dec, end) <- tmp
				if asc.isEmpty || dec.isEmpty || (ref.node +: asc.map(_._1)).takeRight(2).head != dec.head._2
				if end.node.selection == null
			} yield {
				val ret = new Path(ref, asc, dec)
				assert(ret.last == end)
				ret
			}
		}
		
		private[this] def logicallyAlignedUp(ie: IEngine, clueTerms: Set[Term], subPath: Path, supPath: Path) = {
			
			val (aClue1, aClue2) = clue(ie, clueTerms, subPath.start.node.germ(subPath.start.role))
			val (aRefClue1, aRefClue2) = if (subPath.rnrs.length >= 2) {
				val (tmp1, tmp2) = clue(ie, clueTerms, subPath.rnrs(1)._2.germ(subPath.rnrs(1)._1))
				(aClue1 -- tmp1, aClue2 -- tmp2)
			} else {
				(aClue1, aClue2)
			}
			
			val (bClue1, bClue2) = clue(ie, clueTerms, supPath.start.node.germ(supPath.start.role))
			val (bRefClue1, bRefClue2) = if (supPath.rnrs.length >= 2) {
				val (tmp1, tmp2) = clue(ie, clueTerms, supPath.rnrs(1)._2.germ(supPath.rnrs(1)._1))
				(bClue1 -- tmp1, bClue2 -- tmp2)
			} else {
				(bClue1, bClue2)
			}
			
			!(aRefClue1 intersect bRefClue1).isEmpty || !(aRefClue2 intersect bRefClue2).isEmpty
		}
		
		private[this] def notClue(ie: IEngine, clueTerms: Set[Term], path: Path) = {
			val nodes = path.rnrs.map(_._2).toSet
			var ret = Set.empty[Term]
			for (n <- nodes; wd = n.token.getWord; if !wd.isStopWord) {
				val ws = DenotationWordSign(n.rseq.toSet, wd, n.sign)
				for (den <- wordPIs(ws)) {
					ret ++= clue(ie, clueTerms, den)._1
				}
			}
			ret
		}
		
		private[this] def logicallyAlignedDown(ie: IEngine, clueTerms: Set[Term], subPath: Path, supPath: Path) = {
			
			val an = subPath.last.node
			val bn = supPath.last.node
			
			(an.children.isEmpty && bn.children.isEmpty) || {
				
				val aNot = notClue(ie, clueTerms, subPath)
				val bNot = notClue(ie, clueTerms, supPath)
				
				val aClue1 = clue(ie, clueTerms, subPath.start.node.germ(subPath.start.role))._1
				val bClue1 = clue(ie, clueTerms, supPath.start.node.germ(supPath.start.role))._1
				
				an.rseq.exists(ar => bn.rseq.exists(br => {
					val aEnd = clue(ie, clueTerms, an.germ(ar))._1 -- aNot
					val bEnd = clue(ie, clueTerms, bn.germ(br))._1 -- bNot
					!((aEnd intersect bEnd) -- (aClue1 intersect bClue1)).isEmpty
				}))
			}
		}
		
		private[this] def signMatch(subPath: Path, supPath: Path) = {
			val tmpsub = (true /: subPath.rnrs.map(_._2.sign))(_ == _)
			val tmpsup = (true /: supPath.rnrs.map(_._2.sign))(_ == _)
			tmpsub == tmpsup
		}
		
		private[this] def headStopWord(path: Path) = {
			path.headWords.forall(_.isStopWord)
		}
		
		private[this] def headNamedEntity(path: Path) = {
			path.headWords.exists(_.isNamedEntity)
		}
		
	}
	
}
